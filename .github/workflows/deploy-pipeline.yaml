name: Deploy changed services

on:
  push:
    branches: [ main ]

jobs:
  detect-changes:
    runs-on: ubuntu-latest
    defaults:
      run:
        shell: bash
    outputs:
      matrix-json: ${{ steps.matrix.outputs.json }}

    steps:
      - uses: actions/checkout@v4
        with:
          fetch-depth: 0 # Required to diff with github.event.before

      - name: Detect changed folders
        id: folders
        run: |
          echo "Comparing ${{ github.event.before }} with ${{ github.sha }}"
          # Ensure github.event.before is not the zero SHA (e.g., for new branches, though less likely for main)
          # For the first push to a main branch, this might list all files if 'before' is null.
          # However, for subsequent pushes to main, this is reliable.
          if [[ "${{ github.event.before }}" == "0000000000000000000000000000000000000000" ]]; then
            echo "Initial push or history unavailable for diff base. Detecting all relevant folders."
            # Fallback: list all directories containing a deploy.yml
            # This part might need adjustment based on desired behavior for an 'initial' commit scenario.
            # For simplicity, keeping the original diff logic which is fine for pushes to an existing main.
            # If you need a robust solution for new branches / initial main push, consider `actions/get-changed-files`.
            changed_files=$(git diff-tree --no-commit-id --name-only -r "${{ github.sha }}" HEAD^)
          else
            changed_files=$(git diff --name-only "${{ github.event.before }}" "${{ github.sha }}")
          fi
          
          folders=$(echo "$changed_files" \
                     | cut -d/ -f1 \
                     | sort -u \
                     | tr '\n' ' ')
          echo "Detected changed top-level folders: '$folders'"
          echo "list=$folders" >> "$GITHUB_OUTPUT"

      - name: Collect deploy configs → matrix JSON
        id: matrix
        run: |
          # pip install yq installs kislyuk/yq, which is a jq wrapper for YAML.
          # The syntax yq -r '.key' is for kislyuk/yq.
          pip install -q yq jq
          rows=()
          echo "Folders to check for deploy.yml: ${{ steps.folders.outputs.list }}"
          for dir in ${{ steps.folders.outputs.list }}; do
            # Ensure dir is not empty or whitespace
            if [[ -z "$dir" || "$dir" =~ ^[[:space:]]*$ ]]; then
              continue
            fi
            cfg_file="$dir/deploy.yml"
            echo "Checking for $cfg_file"
            if [[ -f "$cfg_file" ]]; then
              # kislyuk/yq -r '.key' outputs the raw string value, or the string "null" if missing/null.
              svc_val=$(yq -r '.service' "$cfg_file")
              cmp_val=$(yq -r '.compose' "$cfg_file")

              # Validate that values are not the string "null" and are not empty strings
              if [[ "$svc_val" != "null" && -n "$svc_val" && "$cmp_val" != "null" && -n "$cmp_val" ]]; then
                echo "  ✅ Found valid config in $cfg_file: service='$svc_val', compose='$cmp_val'"
                rows+=("{\"service\":\"$svc_val\",\"compose\":\"$cmp_val\"}")
              else
                echo "  ⚠️ Skipping $cfg_file: 'service' or 'compose' field is missing, null, or empty."
                [[ "$svc_val" == "null" || -z "$svc_val" ]] && echo "     Service value: '$svc_val'"
                [[ "$cmp_val" == "null" || -z "$cmp_val" ]] && echo "     Compose value: '$cmp_val'"
              fi
            else
              echo "  ℹ️ $cfg_file not found, skipping."
            fi
          done
          
          json_output=$(printf '%s\n' "${rows[@]}" | jq -cs '.')
          echo "Generated matrix JSON: $json_output"
          echo "json=$json_output" >> "$GITHUB_OUTPUT"

  deploy:
    needs: detect-changes
    # Condition to run only if there are services to deploy
    if: ${{ needs.detect-changes.outputs.matrix-json != '[]' && needs.detect-changes.outputs.matrix-json != '' }}
    runs-on: ubuntu-latest
    strategy:
      matrix:
        # fromJson will parse the JSON string from the previous job's output
        include: ${{ fromJson(needs.detect-changes.outputs.matrix-json) }}
    defaults:
      run:
        shell: bash

    steps:
      - name: Deploy ${{ matrix.service }}
        env:
          SSH_KEY:     ${{ secrets.ssh_key }}
          SERVER_IP:   ${{ secrets.server_ip }}
          SSH_USER:    ${{ secrets.deploy_user }}
          SVC_NAME:    ${{ matrix.service }}
          COMPOSE_DIR: ${{ matrix.compose }}
        run: |
          set -euo pipefail # Exit on error, undefined variable, or pipe failure

          echo "🚀 Starting deployment for service: $SVC_NAME"
          echo "Target server: $SSH_USER@$SERVER_IP"
          echo "Compose directory on server: $COMPOSE_DIR"

          mkdir -p ~/.ssh
          echo "$SSH_KEY" > ~/.ssh/id_rsa
          chmod 600 ~/.ssh/id_rsa

          # Remove any old host key for this IP to prevent conflicts
          # Use || true to prevent failure if the key doesn't exist or ssh-keygen -R fails
          echo "Removing old host key for $SERVER_IP (if any)..."
          ssh-keygen -R "$SERVER_IP" || true
          
          # Add the current host key to known_hosts
          # -H hashes the hostname/IP for security
          echo "Scanning and adding host key for $SERVER_IP..."
          ssh-keyscan -H "$SERVER_IP" >> ~/.ssh/known_hosts

          echo "🔧 Deploying $SVC_NAME (compose dir: $COMPOSE_DIR) via SSH..."

          # SSH into the server and execute the deployment script.
          # No -o StrictHostKeyChecking=no needed, as we've updated known_hosts.
          # SSH will use the key from known_hosts.
          ssh -i ~/.ssh/id_rsa "$SSH_USER@$SERVER_IP" \
            bash -s -- "$SVC_NAME" "$COMPOSE_DIR" <<'EOSSH'
          set -euo pipefail # Robust script execution on the remote server
          
          svc_name="$1"
          compose_dir="$2"

          echo "  [Remote] Received service: $svc_name"
          echo "  [Remote] Received compose directory: $compose_dir"

          if [[ ! -d "$compose_dir" ]]; then
            echo "  [Remote] ❌ Error: Compose directory '$compose_dir' does not exist on the server."
            exit 1
          fi
          
          cd "$compose_dir"
          echo "  [Remote] Changed directory to $compose_dir"

          # Check if the service exists in the Docker Compose configuration
          if docker compose config --services | grep -qx "$svc_name"; then
            echo "  [Remote] ▶ Building $svc_name..."
            docker compose build "$svc_name"
            echo "  [Remote] ▶ Restarting $svc_name..."
            docker compose up -d "$svc_name" # Creates and starts/restarts the service
            echo "  [Remote] ✅ Successfully deployed $svc_name."
          else
            echo "  [Remote] ⚠️ Warning: Service '$svc_name' not found in Docker Compose configuration in '$compose_dir'. Skipped."
          fi
EOSSH
          echo "✅ Deployment script finished for $SVC_NAME."